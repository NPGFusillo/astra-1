#!/usr/bin/env python3
import typer
from typing import Optional
from typing_extensions import Annotated

app = typer.Typer()

# TODO: make spectrum_model an enumerated type for tab
@app.command()
def run(
    task: Annotated[str, typer.Argument(help="The task name to run (e.g., `aspcap`, or `astra.pipelines.aspcap.aspcap`).")],
    spectrum_model: Annotated[str, typer.Argument(
        help=(
            "The spectrum model to use (e.g., `ApogeeCombinedSpectrum`, `BossCombinedSpectrum`). "
            "If `None` is given then all spectrum models accepted by the task will be analyzed."
        )
        )] = None,
    limit: Annotated[int, typer.Option(help="Limit the number of spectra.")] = None,
    page: Annotated[int, typer.Option(help="Page to start results from (`limit` spectra per `page`).")] = None,
):
    """Run an Astra task on spectra."""
    from rich.progress import Progress, SpinnerColumn, TextColumn, TaskProgressColumn, TimeRemainingColumn, BarColumn, MofNCompleteColumn 
    
    from peewee import JOIN
    from astra import models, __version__
    from astra.models.source import Source
    from astra.models.spectrum import Spectrum
    from astra.utils import resolve_task, get_return_type, expects_spectrum_types, version_string_to_integer

    current_version = version_string_to_integer(__version__) // 1000
    with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}")) as p:
        t = p.add_task(description="Resolving task", total=None)
        fun = resolve_task(task)
        p.remove_task(t)

    messages = []
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        MofNCompleteColumn(),
        TimeRemainingColumn(),
        transient=True
    ) as p:
        
        if spectrum_model is None:
            spectrum_models = expects_spectrum_types(fun)
        else:
            spectrum_models = (getattr(models, spectrum_model), )

        output_model = get_return_type(fun)
        
        n = 0
        for model in spectrum_models:
            if limit is not None and n >= limit:
                break
            t = p.add_task(description=f"Running {fun.__name__} on {model.__name__}", total=limit)
            q = (
                model
                .select(model, Source)
                .join(Source, attr="source")
                .switch(model)
                .join(Spectrum)
                .join(
                    output_model, 
                    JOIN.LEFT_OUTER, 
                    on=(
                        (output_model.v_astra_major_minor == current_version)
                    &   (model.spectrum_pk == output_model.spectrum_pk)
                    )
                )
                .where(
                    output_model.spectrum_pk.is_null()
                |   (model.modified > output_model.modified)
                )                
            )
            if limit is not None:
                if page is not None:
                    q = q.paginate(page, limit)
                else:
                    q = q.limit(limit)

            total = q.count()
            p.update(t, total=total)
            if total > 0:
                for r in fun(q):
                    p.advance(t)
            p.update(t, completed=True)
            n += total
            messages.append(f"Processed {n} {model.__name__} spectra with {fun.__name__}")
    
    list(map(typer.echo, messages))


@app.command()
def migrate(
    apred: Optional[str] = typer.Option(None, help="APOGEE data reduction pipeline version."),
    run2d: Optional[str] = typer.Option(None, help="BOSS data reduction pipeline version."),
):
    """Migrate spectra and auxillary information to the Astra database."""

    import os
    import multiprocessing as mp
    from signal import SIGKILL
    from rich.progress import Text, Progress, SpinnerColumn, Text, TextColumn, TaskProgressColumn, TimeRemainingColumn, TimeElapsedColumn, BarColumn, MofNCompleteColumn as _MofNCompleteColumn

    class MofNCompleteColumn(_MofNCompleteColumn):
        def render(self, task):
            completed = int(task.completed)
            total = f"{int(task.total):,}" if task.total is not None else "?"
            total_width = len(str(total))
            return Text(
                f"{completed:{total_width},d}{self.separator}{total}",
                style="progress.download",
            )

    from astra.migrations.boss import migrate_from_spall_file
    from astra.migrations.apogee import (
        migrate_apvisit_metadata_from_image_headers,
    )
    from astra.migrations.catalog import (
        migrate_healpix,
        migrate_twomass_photometry,
        migrate_unwise_photometry,
        migrate_glimpse_photometry,
        migrate_tic_v8_identifier,
        migrate_gaia_source_ids,
        migrate_gaia_dr3_astrometry_and_photometry,
        migrate_zhang_stellar_parameters,
        migrate_bailer_jones_distances,
        migrate_gaia_synthetic_photometry
    )
    from astra.migrations.misc import (
        compute_f_night_time_for_boss_visits,
        compute_f_night_time_for_apogee_visits,
        update_visit_spectra_counts,       
        compute_n_neighborhood,
        update_galactic_coordinates,
        compute_w1mag_and_w2mag,
        fix_unsigned_apogee_flags
    )
    from astra.migrations.reddening import update_reddening
    from astra.migrations.targeting import (
        migrate_carton_assignments_to_bigbitfield,
        migrate_targeting_cartons
    )
    from astra.utils import silenced

    ptq = []
    try:
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            MofNCompleteColumn(),
            TimeElapsedColumn(),
            TimeRemainingColumn(),
            transient=True
        ) as progress:

            def process_task(target, *args, description=None, **kwargs):
                queue = mp.Queue()

                kwds = dict(queue=queue)
                kwds.update(kwargs)
                process = mp.Process(target=target, args=args, kwargs=kwds)
                process.start()

                task = progress.add_task(description=(description or ""), total=None)
                return (process, task, queue)

            
            if apred is not None or run2d is not None:
                if apred is not None:
                    if apred == "dr17":
                        from astra.migrations.apogee import migrate_sdss4_dr17_apogee_spectra_from_sdss5_catalogdb 
                        ptq.append(process_task(migrate_sdss4_dr17_apogee_spectra_from_sdss5_catalogdb, description="Ingesting APOGEE dr17 spectra"))
                    else:
                        raise a
                if run2d is not None:
                    ptq.append(process_task(migrate_from_spall_file, run2d, description=f"Ingesting BOSS {run2d} spectra"))
                                
                awaiting = set(t for p, t, q in ptq)
                while awaiting:
                    for p, t, q in ptq:
                        try:
                            r = q.get(False)
                            if r is Ellipsis:
                                progress.update(t, completed=True)
                                awaiting.remove(t)
                                p.join()
                                progress.update(t, visible=False)
                            else:
                                progress.update(t, **r)
                                if "completed" in r and r.get("completed", None) == 0:
                                    # reset the task
                                    progress.reset(t)
                        except mp.queues.Empty:
                            pass

            # Now that we have sources and spectra, we can do other things.
            ptq = [
                process_task(migrate_gaia_source_ids, description="Ingesting Gaia DR3 source IDs"),
                process_task(migrate_twomass_photometry, description="Ingesting 2MASS photometry"),
                process_task(migrate_unwise_photometry, description="Ingesting unWISE photometry"),
                process_task(migrate_glimpse_photometry, description="Ingesting GLIMPSE photometry"),
                process_task(migrate_healpix, description="Ingesting HEALPix values"),
                process_task(migrate_tic_v8_identifier, description="Ingesting TIC v8 identifiers"),
                process_task(migrate_apvisit_metadata_from_image_headers, description="Ingesting apVisit metadata"),
                process_task(update_galactic_coordinates, description="Computing Galactic coordinates"),
                process_task(fix_unsigned_apogee_flags, description="Fix unsigned APOGEE flags"),
                #process_task(migrate_carton_assignments_to_bigbitfield, description="Ingesting targeting cartons"),
                process_task(migrate_targeting_cartons, description="Ingesting targeting cartons"),
                process_task(compute_f_night_time_for_boss_visits, description="Computing f_night for BOSS visits"),
                process_task(compute_f_night_time_for_apogee_visits, description="Computing f_night for APOGEE visits"),                        
                process_task(update_visit_spectra_counts, description="Updating visit spectra counts"),               
            ]
            # reddening needs unwise, 2mass, glimpse, 
            task_gaia, task_twomass, task_unwise, task_glimpse, *_ = [t for p, t, q in ptq]
            reddening_requires = {task_twomass, task_unwise, task_glimpse, task_gaia}
            started_reddening = False
            awaiting = set(t for p, t, q in ptq)
            while awaiting:
                additional_tasks = []
                for p, t, q in ptq:
                    try:
                        r = q.get(False)
                        if r is Ellipsis:
                            progress.update(t, completed=True)
                            awaiting.remove(t)
                            p.join()
                            progress.update(t, visible=False)
                            if t == task_gaia:
                                # Add a bunch more tasks!
                                new_tasks = [
                                    process_task(migrate_gaia_dr3_astrometry_and_photometry, description="Ingesting Gaia DR3 astrometry and photometry"),
                                    process_task(migrate_zhang_stellar_parameters, description="Ingesting Zhang stellar parameters"),
                                    process_task(migrate_bailer_jones_distances, description="Ingesting Bailer-Jones distances"),                 
                                    # commented out only because we are getting deadlock errors caused by some other process.               
                                    #process_task(migrate_gaia_synthetic_photometry, description="Ingesting Gaia synthetic photometry"),
                                    process_task(compute_n_neighborhood, description="Computing n_neighborhood"),
                                ]
                                reddening_requires.update({t for p, t, q in new_tasks[:3]}) # reddening needs Gaia astrometry, Zhang parameters, and Bailer-Jones distances
                                additional_tasks.extend(new_tasks)
                            if t == task_unwise:
                                additional_tasks.append(
                                    process_task(compute_w1mag_and_w2mag, description="Computing W1, W2 mags")
                                )
                            if not started_reddening and not (awaiting & reddening_requires):
                                started_reddening = True
                                #additional_tasks.append(
                                #    process_task(update_reddening, description="Computing extinction")
                                #)
                        else:
                            progress.update(t, **r)
                            if "completed" in r and r.get("completed", None) == 0:
                                # reset the task
                                progress.reset(t)

                    except mp.queues.Empty:
                        pass

                ptq.extend(additional_tasks)
                awaiting |= set(t for p, t, q in additional_tasks)

    except KeyboardInterrupt:  
        """
        with silenced():
            import psutil
            parent = psutil.Process(os.getpid())
            for child in parent.children(recursive=True):
                child.kill()
        """
        raise KeyboardInterrupt



@app.command()
def init(
    drop_tables: Optional[bool] = typer.Option(False, help="Drop tables if they exist."), 
    delay: Optional[int] = typer.Option(10, help="Delay in seconds to wait.")
):
    """Initialize the Astra database."""

    from time import sleep
    from rich.progress import Progress, SpinnerColumn, TextColumn, TaskProgressColumn, TimeRemainingColumn
    from importlib import import_module
    from astra.models.base import (database, BaseModel)
    from astra.models.pipeline import PipelineOutputModel

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        TimeRemainingColumn(),
        transient=True
    ) as progress:

        init_model_packages = (
            "apogee",
            "boss",
            "apogeenet",
            "astronn_dist",
            "astronn",
            "source",
            "spectrum",
        )
        for package in init_model_packages:
            import_module(f"astra.models.{package}")
        
        models = set(BaseModel.__subclasses__()) - {PipelineOutputModel}
        
        if drop_tables:
            tables_to_drop = [m for m in models if m.table_exists()]
            if delay > 0:
                t = progress.add_task(description=f"About to drop {len(tables_to_drop)} tables..", total=delay)
                for i in range(delay):
                    progress.advance(t)
                    sleep(1)
        
            with database.atomic():
                database.drop_tables(tables_to_drop, cascade=True)
            progress.remove_task(t)

        t = progress.add_task(description="Creating tables", total=len(models))
        with database.atomic():
            database.create_tables(models)
        

if __name__ == "__main__":
    app()